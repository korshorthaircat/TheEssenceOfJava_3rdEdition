# 1. 람다식
* 자바의 새로운 변화
    * JDK1.5 - 지네릭스
    * JDK1.8 - 람다식
        * 람다식의 도입으로 인해 자바는 객체지향언어인 동시에 함수형 언어가 되었음
        * 기존의 자바를 거의 변경하지 않고도 함수형 언어의 장점을 잘 접목시킴
      
## 1.1 람다식이란?
* 람다식(Lambda Expression)
  * 메서드를 하나의 식expression으로 표현한 것
  * '익명함수(anonymous function)'이라고도 함
    * 메서드의 이름과 반환값이 없어지기 때문
  * 예)
    ```java
    int[] arr = new int[5];
    Arrays.setAll(arr, (i) -> (int)(Math.random() * 5) + 1);
* 메서드와 비교했을 때의 장점
  * 간결하며 이해하기 쉬움
  * 모든 메서드는 클래스에 포함되어야 하므로, 메서드의 경우 클래스도 새로 만들어야 하고, 객체도 생성해야만 비로소 그 메서드를 호출할 수 있음.
    * --> 하지만 람다식은 이러한 과정 없이 오직 람다식 자체만으로도 메서드의 역할을 대체할 수 있음
  * 메서드를 변수처럼 다루는 것이 가능해짐
    * 메서드의 매개변수로 전달되어지는 것이 가능함
    * 메서드의 결과로 반환될 수도 있음
* 메서드와 함수의 차이
  * 메서드는 함수와 같은 의미이지만, 특정 클래스에 반드시 속해야 한다는 제약이 있으므로 객체지향개념에서는 '함수'와는 다른 용어를 선택해 사용함
  * 그러나 이제 다시 람다식을 통해 메서드가 하나의 독립적 기능을 하게 되었으므로, '함수'라는 용어를 사용함

## 1.2 람다식 작성하기
    (매개변수 선언) -> { 문장들 }
* 메서드와 람다식의 형식 비교
  ```java
  //메서드
  int max(int a, int b) {
    return a > b ? a : b;
  }
  //람다식
  (int a, int b) -> {
    return a > b ? a : b;
  }
* 람다식 작성법
  * 반환값이 있는 메서드의 경우
    * --> return문 대신 식으로 표현할 수 있음(식 연산결과가 자동적으로 반환됨)
    * 이 때는 문장statement이 아니라 '식'이므로 끝에 세미콜론을 붙이지 않음
    ```java
    (int a, int b) -> a > b ? a : b
  * 람다식에 선언된 매개변수의 타입을 추론 가능한 경우(대부분의 경우)
    * --> 매개변수타입 생략 가능
    ```java
    (a, b) -> a > b ? a : b
  * 선언된 매개변수가 하나뿐인 경우
    * --> () 괄호 생략 **가능**
    ```java
    a -> a * a //Ok
  * 선언된 매개변수가 하나뿐이고 **타입이 있는 경우**
    * --> () 괄호 생략 **불가**
    ```java
    (int a) -> a * a
  * 괄호 {}안의 문장이 하나인 경우
    * --> {} 괄호 생략 **가능**
    ```java
    (String name, int i) -> System.out.println(name + "=" + i)
  * 괄호 {} 안의 문장이 하나이지만 **return문인 경우**
    * --> {} 괄호 생략 **불가**
    ```java
    (int a, int b) -> { return a > b ? a : b; }

## 1.3 함수형 인터페이스(Functional Interface)
* <u>람다식은 실제로는 **익명 객체**이다.</u>
    ```java
  //람다식은
  (int a, int b) -> a > b ? a : b 
  //익명 클래스의 객체와
  new Object() { int max(int a, int b) {return a > b ? a : b;}} 
  //동등하다. 
* 람다식으로 정의된 익명객체의 메서드를 어떻게 호출할 수 있는가?  
  * ```java
    //익명 객체의 주소를 f라는 참조변수로 저장
    타입 f = (int a, int b) -> a > b ? a : b;
    //참조변수 f의 타입은 무엇으로 해야하는가?
    // --> 클래스 또는 인터페이스가 가능하다. 단, 람다식과 동등한 메서드가 정의되어 있어야 한다. (그래야 호출 가능하니까...)
  * 
      ```java
    //메서드가 정의된 인터페이스
    interface MyFunction { public abstract int max(int a, int b); }
    //위의 인터페이스를 구현한 익명 클래스의 객체
    MyFunction f = new MyFunction() {
        public int max(int a, int b) {
            return a > b ? a : b;
        }
    };
    //익명 객체의 메서드를 호출
    int big = f.max(5, 3);
  *
    ```java
    //익명객체를 람다식으로 대체
    MyFunction f = (int a, int b) -> a > b ? a : b;
    //익명 객체의 메서드를 호출
    int big = f.max(5,3);
* 함수형 인터페이스(Functional Interface)
  * 하나의 메서드가 선언된 인터페이스를 정의해 람다식을 다루는 것은 기존의 자바 규칙들을 어기지 않으면서도 자연스럽다.
  * 그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며,
  * 람다식을 다루기 위한 인터페이스를 '함수형 인터페이스'라고 부른다.
  *     
    ```java
    @FunctionalInterface //이 어노테이션을 붙이면, 컴파일러가 항상 함수형 인터페이스를 올바르게 정의했는지 확인해준다. 
    interface MyFunction { //함수형 인터페이스 MyFunction을 정의 
        public abstract int max(int a, int b);
    } 
  * 함수형 인터페이스의 제약
    * <u>함수형 인터페이스에는 오직 하나의 추상메서드만 정의</u>되어 있어야 한다.
      * 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문
    * static메서드와 default메서드의 개수에는 제약이 없다. 

### 함수형 인터페이스 타입의 매개변수와 반환타입
1. 메서드의 <u>매개변수가 함수형 인터페이스 타입</u>일 때
   *  ```java
      //함수형 인터페이스가 다음과 같이 정의되어 있을 때, 
      @FunctionalInterface
      interface MyFunction { 
        void myMethod(); //추상메서드
      }
      //메서드의 매개변수 MyFunction타입이면,
      //이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻!
      void aMethod(MyFunction f) { //매개변수 타입이 함수형 인터페이스
        f.myMethd(); //MyFunction에 정의된 메서드 호출
      }
      ...
      MyFunction f = () -> System.out.println("myMethod()");
      aMethod(f);
      //혹은 참조변수 없이 직접 람다식을 매개변수로 지정하는 것도 가능하다.
      aMethod(() -> System.out.println("myMethod()")); //람다식을 매개변수로 지정
   
2. 메서드의 <u>반환타입이 함수형 인터페이스 타입</u>일 때
   * 함수형 인터페이스의 추상메서드와 동등한 람다식을 가리키는 참조변수를 반환하거나, 람다식을 직접 반환할 수 있다.
   * ```java
     MyFunction myMethod() {
      MyFunction f = () -> {};
      return f; //이 줄과 윗 줄을 한 줄로 줄이면, return () -> {};
     }
3. 람다식을 참조변수로 다룰 수 있다는 것의 의미
  * 메서드를 통해 람다식을 주고받을 수 있다!
  * 변수처럼 메서드를 주고받는 일이 가능하다!
    * 사실상 메서드가 아니라 (익명)객체를 주고받는 것이라 근본적으로 달라진 것은 없지만, 람다식 덕분에 코드가 간결하고 이해하기 쉬워진다. 

### 람다식의 타입과 형변환
* 람다식의 타입
  * 함수형 인터페이스로 람다식을 참조할 수는 있지만, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다!
  * 람다식은 익명객체이고, 익명객체는 타입이 없다.
    * 정확히 말하자면, 타입은 있지만 컴파일러가 이름을 임의로 정하기 때문에 알 수 없다.
    * 따라서 대입 연산자의 양변의 타입을 일치시키기 위해 형변환이 필요하다.
      * 람다식은 이름이 없을 뿐, 분명히 객체이지만 Object타입으로 형변환 불가능하다.
      * 오직 함수형 인터페이스로만 형변환 가능하다.
    * ```java
      MyFunction f = (MyFunction)(() -> {}); //양변의 타입이 다르므로 형변환 필요 
      //이하는 에러
      Object obj = (Object)(() -> {}); //에러!

### 외부변수를 참조하는 람다식 
* 람다식 내에서 외부에 선언된 변수에 접근하기
  * 람다식 내에서 참조하는 지역변수는 final이 붙지 않아도 상수로 간주된다.
  * LambdaEx3.java 참고

## 1.4 java.util.function 패키지

## 1.5 Function의 합성과 Predicate의 결합

## 1.6 메서드 참조